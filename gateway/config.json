{"engineConfig":{"defaultFlushInterval":"500","datasourceConfigurations":[{"kind":"GRAPHQL","rootNodes":[{"typeName":"Product","fieldNames":["description","id","name"]},{"typeName":"Query","fieldNames":["product","products"]}],"overrideFieldPathFromAlias":true,"customGraphql":{"fetch":{"url":{"staticVariableContent":"http://localhost:18482/graphql"},"method":"POST","body":{},"baseUrl":{},"path":{}},"subscription":{"enabled":true,"url":{"staticVariableContent":"http://localhost:18482/graphql"},"protocol":"GRAPHQL_SUBSCRIPTION_PROTOCOL_WS"},"federation":{"enabled":true,"serviceSdl":"schema {\n  query: Query\n}\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users.\"\ndirective @authenticated on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Indicates to composition that all uses of a particular custom type system directive in the subgraph schema should be preserved in the supergraph schema (by default, composition omits most directives from the supergraph schema).\"\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object or interface definition is an extension of another definition of that same type.\nIf your subgraph library supports GraphQL's built-in extend keyword, do not use this directive! Instead, use extend.\n\"\"\"\ndirective @extends on OBJECT | INTERFACE\n\n\"\"\"\nIndicates that this subgraph usually can't resolve a particular object field, but it still needs to define that field for other purposes.\nThis directive is always used in combination with another directive that references object fields, such as @provides or @requires.\n\"\"\"\ndirective @external on OBJECT | FIELD_DEFINITION\n\n\"Indicates that a definition in the subgraph schema should be omitted from the router's API schema, even if that definition is also present in other subgraphs. This means that the field is not exposed to clients at all.\"\ndirective @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object definition serves as an abstraction of another subgraph's entity interface. This abstraction enables a subgraph to automatically contribute fields to all entities that implement a particular entity interface.\nDuring composition, the fields of every @interfaceObject are added both to their corresponding interface definition and to all entity types that implement that interface.\n\"\"\"\ndirective @interfaceObject on OBJECT\n\n\"Designates an object type as an entity and specifies its key fields (a set of fields that the subgraph can use to uniquely identify any instance of the entity). You can apply multiple @key directives to a single entity (to specify multiple valid sets of key fields).\"\ndirective @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE\n\n\"This directive links definitions from an external specification to this schema.\"\ndirective @link(as: String, for: Purpose, import: [Import], url: String!) repeatable on SCHEMA\n\n\"\"\"\nIndicates that an object field is now resolved by this subgraph instead of another subgraph where it's also defined. This enables you to migrate a field from one subgraph to another.\nYou can apply @override to entity fields and fields of the root operation types (such as Query and Mutation).\n\"\"\"\ndirective @override(from: String!, label: String) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"\"\"\nSpecifies a set of entity fields that a subgraph can resolve, but only at a particular schema path (at other paths, the subgraph can't resolve those fields).\nIf a subgraph can always resolve a particular entity field, do not apply this directive.\nUsing this directive is always an optional optimization. It can reduce the total number of subgraphs that your graph router needs to communicate with to resolve certain operations, which can improve performance.\n\"\"\"\ndirective @provides(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates that the resolver for a particular entity field depends on the values of other entity fields that are resolved by other subgraphs. This tells the graph router that it needs to fetch the values of those externally defined fields first, even if the original client query didn't request them.\"\ndirective @requires(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users with the appropriate JWT scopes\"\ndirective @requiresScopes(scopes: [[Scope!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\n\"Indicates that an object type's field is allowed to be resolved by multiple subgraphs (by default in Federation 2, object fields can be resolved by only one subgraph).\"\ndirective @shareable repeatable on OBJECT | FIELD_DEFINITION\n\n\"Applies arbitrary string metadata to a schema location. Custom tooling can use this metadata during any step of the schema delivery flow, including composition, static analysis, and documentation. Apollo Studio's enterprise contracts feature uses @tag with its inclusion and exclusion filters.\"\ndirective @tag(name: String!) repeatable on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\nunion _Entity = Product\n\n\"Something you can buy\"\ntype Product @key(fields : \"id\") {\n  description: String\n  id: ID\n  name: String\n}\n\n\"Query root\"\ntype Query {\n  _entities(representations: [_Any!]!): [_Entity]!\n  _service: _Service!\n  product(id: ID): Product\n  products(ids: [String]): [Product]\n}\n\ntype _Service {\n  sdl: String!\n}\n\nenum Purpose {\n  \"`EXECUTION` features provide metadata necessary for operation execution.\"\n  EXECUTION\n  \"`SECURITY` features provide metadata necessary to securely resolve fields.\"\n  SECURITY\n}\n\n\"Scalar for BigDecimal\"\nscalar BigDecimal\n\n\"Scalar for BigInteger\"\nscalar BigInteger\n\n\"Scalar for FieldSet\"\nscalar FieldSet\n\n\"Scalar for Import\"\nscalar Import\n\n\"Scalar for Policy\"\nscalar Policy\n\n\"Scalar for Scope\"\nscalar Scope\n\nscalar _Any"},"upstreamSchema":{"key":"932ef38ead7cdc1bd105be7e2d126039ba7d0b1d"}},"requestTimeoutSeconds":"10","id":"0","keys":[{"typeName":"Product","selectionSet":"id"}]},{"kind":"GRAPHQL","rootNodes":[{"typeName":"Product","fieldNames":["id"]},{"typeName":"Order","fieldNames":["customerName","customerNumber","id","orderDate","orderItems","orderNumber"]},{"typeName":"Query","fieldNames":["order"]}],"childNodes":[{"typeName":"OrderItem","fieldNames":["amount","id","position","product","productId"]}],"overrideFieldPathFromAlias":true,"customGraphql":{"fetch":{"url":{"staticVariableContent":"http://localhost:18483/graphql"},"method":"POST","body":{},"baseUrl":{},"path":{}},"subscription":{"enabled":true,"url":{"staticVariableContent":"http://localhost:18483/graphql"},"protocol":"GRAPHQL_SUBSCRIPTION_PROTOCOL_WS"},"federation":{"enabled":true,"serviceSdl":"schema {\n  query: Query\n}\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users.\"\ndirective @authenticated on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Indicates to composition that all uses of a particular custom type system directive in the subgraph schema should be preserved in the supergraph schema (by default, composition omits most directives from the supergraph schema).\"\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object or interface definition is an extension of another definition of that same type.\nIf your subgraph library supports GraphQL's built-in extend keyword, do not use this directive! Instead, use extend.\n\"\"\"\ndirective @extends on OBJECT | INTERFACE\n\n\"\"\"\nIndicates that this subgraph usually can't resolve a particular object field, but it still needs to define that field for other purposes.\nThis directive is always used in combination with another directive that references object fields, such as @provides or @requires.\n\"\"\"\ndirective @external on OBJECT | FIELD_DEFINITION\n\n\"Indicates that a definition in the subgraph schema should be omitted from the router's API schema, even if that definition is also present in other subgraphs. This means that the field is not exposed to clients at all.\"\ndirective @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object definition serves as an abstraction of another subgraph's entity interface. This abstraction enables a subgraph to automatically contribute fields to all entities that implement a particular entity interface.\nDuring composition, the fields of every @interfaceObject are added both to their corresponding interface definition and to all entity types that implement that interface.\n\"\"\"\ndirective @interfaceObject on OBJECT\n\n\"Designates an object type as an entity and specifies its key fields (a set of fields that the subgraph can use to uniquely identify any instance of the entity). You can apply multiple @key directives to a single entity (to specify multiple valid sets of key fields).\"\ndirective @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE\n\n\"This directive links definitions from an external specification to this schema.\"\ndirective @link(as: String, for: Purpose, import: [Import], url: String!) repeatable on SCHEMA\n\n\"\"\"\nIndicates that an object field is now resolved by this subgraph instead of another subgraph where it's also defined. This enables you to migrate a field from one subgraph to another.\nYou can apply @override to entity fields and fields of the root operation types (such as Query and Mutation).\n\"\"\"\ndirective @override(from: String!, label: String) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"\"\"\nSpecifies a set of entity fields that a subgraph can resolve, but only at a particular schema path (at other paths, the subgraph can't resolve those fields).\nIf a subgraph can always resolve a particular entity field, do not apply this directive.\nUsing this directive is always an optional optimization. It can reduce the total number of subgraphs that your graph router needs to communicate with to resolve certain operations, which can improve performance.\n\"\"\"\ndirective @provides(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates that the resolver for a particular entity field depends on the values of other entity fields that are resolved by other subgraphs. This tells the graph router that it needs to fetch the values of those externally defined fields first, even if the original client query didn't request them.\"\ndirective @requires(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users with the appropriate JWT scopes\"\ndirective @requiresScopes(scopes: [[Scope!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\n\"Indicates that an object type's field is allowed to be resolved by multiple subgraphs (by default in Federation 2, object fields can be resolved by only one subgraph).\"\ndirective @shareable repeatable on OBJECT | FIELD_DEFINITION\n\n\"Applies arbitrary string metadata to a schema location. Custom tooling can use this metadata during any step of the schema delivery flow, including composition, static analysis, and documentation. Apollo Studio's enterprise contracts feature uses @tag with its inclusion and exclusion filters.\"\ndirective @tag(name: String!) repeatable on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\nunion _Entity = Order | Product\n\ntype Order @key(fields : \"id\") {\n  customerName: String\n  customerNumber: String\n  id: String\n  \"ISO-8601\"\n  orderDate: Date\n  orderItems: [OrderItem]\n  orderNumber: String\n}\n\ntype OrderItem {\n  amount: Int\n  id: String\n  position: Int\n  product: Product\n  productId: String\n}\n\ntype Product @extends @key(fields : \"id\") {\n  id: ID @external\n}\n\n\"Query root\"\ntype Query {\n  _entities(representations: [_Any!]!): [_Entity]!\n  _service: _Service!\n  order(id: String): Order\n}\n\ntype _Service {\n  sdl: String!\n}\n\nenum Purpose {\n  \"`EXECUTION` features provide metadata necessary for operation execution.\"\n  EXECUTION\n  \"`SECURITY` features provide metadata necessary to securely resolve fields.\"\n  SECURITY\n}\n\n\"Scalar for BigDecimal\"\nscalar BigDecimal\n\n\"Scalar for BigInteger\"\nscalar BigInteger\n\n\"Scalar for Date\"\nscalar Date\n\n\"Scalar for FieldSet\"\nscalar FieldSet\n\n\"Scalar for Import\"\nscalar Import\n\n\"Scalar for Policy\"\nscalar Policy\n\n\"Scalar for Scope\"\nscalar Scope\n\nscalar _Any"},"upstreamSchema":{"key":"87c61368d21b3c5cc06f7664a4d427e6e7ee6444"}},"requestTimeoutSeconds":"10","id":"1","keys":[{"typeName":"Product","selectionSet":"id"},{"typeName":"Order","selectionSet":"id"}]},{"kind":"GRAPHQL","rootNodes":[{"typeName":"Product","fieldNames":["id","price"]},{"typeName":"Query","fieldNames":["productPrice","productPrices"]}],"overrideFieldPathFromAlias":true,"customGraphql":{"fetch":{"url":{"staticVariableContent":"http://localhost:18484/graphql"},"method":"POST","body":{},"baseUrl":{},"path":{}},"subscription":{"enabled":true,"url":{"staticVariableContent":"http://localhost:18484/graphql"},"protocol":"GRAPHQL_SUBSCRIPTION_PROTOCOL_WS"},"federation":{"enabled":true,"serviceSdl":"schema {\n  query: Query\n}\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users.\"\ndirective @authenticated on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Indicates to composition that all uses of a particular custom type system directive in the subgraph schema should be preserved in the supergraph schema (by default, composition omits most directives from the supergraph schema).\"\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object or interface definition is an extension of another definition of that same type.\nIf your subgraph library supports GraphQL's built-in extend keyword, do not use this directive! Instead, use extend.\n\"\"\"\ndirective @extends on OBJECT | INTERFACE\n\n\"\"\"\nIndicates that this subgraph usually can't resolve a particular object field, but it still needs to define that field for other purposes.\nThis directive is always used in combination with another directive that references object fields, such as @provides or @requires.\n\"\"\"\ndirective @external on OBJECT | FIELD_DEFINITION\n\n\"Indicates that a definition in the subgraph schema should be omitted from the router's API schema, even if that definition is also present in other subgraphs. This means that the field is not exposed to clients at all.\"\ndirective @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\n\"\"\"\nIndicates that an object definition serves as an abstraction of another subgraph's entity interface. This abstraction enables a subgraph to automatically contribute fields to all entities that implement a particular entity interface.\nDuring composition, the fields of every @interfaceObject are added both to their corresponding interface definition and to all entity types that implement that interface.\n\"\"\"\ndirective @interfaceObject on OBJECT\n\n\"Designates an object type as an entity and specifies its key fields (a set of fields that the subgraph can use to uniquely identify any instance of the entity). You can apply multiple @key directives to a single entity (to specify multiple valid sets of key fields).\"\ndirective @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE\n\n\"This directive links definitions from an external specification to this schema.\"\ndirective @link(as: String, for: Purpose, import: [Import], url: String!) repeatable on SCHEMA\n\n\"\"\"\nIndicates that an object field is now resolved by this subgraph instead of another subgraph where it's also defined. This enables you to migrate a field from one subgraph to another.\nYou can apply @override to entity fields and fields of the root operation types (such as Query and Mutation).\n\"\"\"\ndirective @override(from: String!, label: String) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"\"\"\nSpecifies a set of entity fields that a subgraph can resolve, but only at a particular schema path (at other paths, the subgraph can't resolve those fields).\nIf a subgraph can always resolve a particular entity field, do not apply this directive.\nUsing this directive is always an optional optimization. It can reduce the total number of subgraphs that your graph router needs to communicate with to resolve certain operations, which can improve performance.\n\"\"\"\ndirective @provides(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates that the resolver for a particular entity field depends on the values of other entity fields that are resolved by other subgraphs. This tells the graph router that it needs to fetch the values of those externally defined fields first, even if the original client query didn't request them.\"\ndirective @requires(fields: FieldSet!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is accessible only to the authenticated supergraph users with the appropriate JWT scopes\"\ndirective @requiresScopes(scopes: [[Scope!]!]!) on SCALAR | OBJECT | FIELD_DEFINITION | INTERFACE | ENUM\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\n\"Indicates that an object type's field is allowed to be resolved by multiple subgraphs (by default in Federation 2, object fields can be resolved by only one subgraph).\"\ndirective @shareable repeatable on OBJECT | FIELD_DEFINITION\n\n\"Applies arbitrary string metadata to a schema location. Custom tooling can use this metadata during any step of the schema delivery flow, including composition, static analysis, and documentation. Apollo Studio's enterprise contracts feature uses @tag with its inclusion and exclusion filters.\"\ndirective @tag(name: String!) repeatable on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION\n\nunion _Entity = Product\n\ntype Product @extends @key(fields : \"id\") {\n  id: ID\n  \"The price in cent\"\n  price: Int\n}\n\n\"Query root\"\ntype Query {\n  _entities(representations: [_Any!]!): [_Entity]!\n  _service: _Service!\n  productPrice(id: ID): Product\n  productPrices(ids: [String]): [Product]\n}\n\ntype _Service {\n  sdl: String!\n}\n\nenum Purpose {\n  \"`EXECUTION` features provide metadata necessary for operation execution.\"\n  EXECUTION\n  \"`SECURITY` features provide metadata necessary to securely resolve fields.\"\n  SECURITY\n}\n\n\"Scalar for BigDecimal\"\nscalar BigDecimal\n\n\"Scalar for BigInteger\"\nscalar BigInteger\n\n\"Scalar for FieldSet\"\nscalar FieldSet\n\n\"Scalar for Import\"\nscalar Import\n\n\"Scalar for Policy\"\nscalar Policy\n\n\"Scalar for Scope\"\nscalar Scope\n\nscalar _Any"},"upstreamSchema":{"key":"5c21f30565a3309126903fe8604576d73d253492"}},"requestTimeoutSeconds":"10","id":"2","keys":[{"typeName":"Product","selectionSet":"id"}]}],"fieldConfigurations":[{"typeName":"Query","fieldName":"product","argumentsConfiguration":[{"name":"id","sourceType":"FIELD_ARGUMENT"}]},{"typeName":"Query","fieldName":"products","argumentsConfiguration":[{"name":"ids","sourceType":"FIELD_ARGUMENT"}]},{"typeName":"Query","fieldName":"order","argumentsConfiguration":[{"name":"id","sourceType":"FIELD_ARGUMENT"}]},{"typeName":"Query","fieldName":"productPrice","argumentsConfiguration":[{"name":"id","sourceType":"FIELD_ARGUMENT"}]},{"typeName":"Query","fieldName":"productPrices","argumentsConfiguration":[{"name":"ids","sourceType":"FIELD_ARGUMENT"}]}],"graphqlSchema":"directive @authenticated on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ndirective @requiresScopes(scopes: [[openfed__Scope!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\nscalar openfed__Scope\n\n\"\"\"Something you can buy\"\"\"\ntype Product {\n  description: String\n  id: ID\n  name: String\n\n  \"\"\"The price in cent\"\"\"\n  price: Int\n}\n\n\"\"\"Query root\"\"\"\ntype Query {\n  product(id: ID): Product\n  products(ids: [String]): [Product]\n  order(id: String): Order\n  productPrice(id: ID): Product\n  productPrices(ids: [String]): [Product]\n}\n\nenum Purpose {\n  \"\"\"\n  `EXECUTION` features provide metadata necessary for operation execution.\n  \"\"\"\n  EXECUTION\n\n  \"\"\"\n  `SECURITY` features provide metadata necessary to securely resolve fields.\n  \"\"\"\n  SECURITY\n}\n\n\"\"\"Scalar for BigDecimal\"\"\"\nscalar BigDecimal\n\n\"\"\"Scalar for BigInteger\"\"\"\nscalar BigInteger\n\n\"\"\"Scalar for FieldSet\"\"\"\nscalar FieldSet\n\n\"\"\"Scalar for Import\"\"\"\nscalar Import\n\n\"\"\"Scalar for Policy\"\"\"\nscalar Policy\n\n\"\"\"Scalar for Scope\"\"\"\nscalar Scope\n\ntype Order {\n  customerName: String\n  customerNumber: String\n  id: String\n\n  \"\"\"ISO-8601\"\"\"\n  orderDate: Date\n  orderItems: [OrderItem]\n  orderNumber: String\n}\n\ntype OrderItem {\n  amount: Int\n  id: String\n  position: Int\n  product: Product\n  productId: String\n}\n\n\"\"\"Scalar for Date\"\"\"\nscalar Date","stringStorage":{"932ef38ead7cdc1bd105be7e2d126039ba7d0b1d":"schema {\n  query: Query\n}\n\ndirective @authenticated on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\ndirective @eventsPublish(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsRequest(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsSubscribe(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @extends on INTERFACE | OBJECT\n\ndirective @external on FIELD_DEFINITION | OBJECT\n\ndirective @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ndirective @interfaceObject on OBJECT\n\ndirective @key(fields: openfed__FieldSet!, resolvable: Boolean = true) repeatable on INTERFACE | OBJECT\n\ndirective @link(as: String, for: String, import: [String], url: String!) repeatable on SCHEMA\n\ndirective @override(from: String!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @provides(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requires(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requiresScopes(scopes: [[openfed__Scope!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\ndirective @shareable on FIELD_DEFINITION | OBJECT\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\n\"\"\"Scalar for BigDecimal\"\"\"\nscalar BigDecimal\n\n\"\"\"Scalar for BigInteger\"\"\"\nscalar BigInteger\n\n\"\"\"Scalar for FieldSet\"\"\"\nscalar FieldSet\n\n\"\"\"Scalar for Import\"\"\"\nscalar Import\n\n\"\"\"Scalar for Policy\"\"\"\nscalar Policy\n\n\"\"\"Something you can buy\"\"\"\ntype Product @key(fields: \"id\") {\n  description: String\n  id: ID\n  name: String\n}\n\nenum Purpose {\n  \"\"\"\n  `EXECUTION` features provide metadata necessary for operation execution.\n  \"\"\"\n  EXECUTION\n  \"\"\"\n  `SECURITY` features provide metadata necessary to securely resolve fields.\n  \"\"\"\n  SECURITY\n}\n\n\"\"\"Query root\"\"\"\ntype Query {\n  product(id: ID): Product\n  products(ids: [String]): [Product]\n}\n\n\"\"\"Scalar for Scope\"\"\"\nscalar Scope\n\nscalar openfed__FieldSet\n\nscalar openfed__Scope","87c61368d21b3c5cc06f7664a4d427e6e7ee6444":"schema {\n  query: Query\n}\n\ndirective @authenticated on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\ndirective @eventsPublish(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsRequest(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsSubscribe(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @extends on INTERFACE | OBJECT\n\ndirective @external on FIELD_DEFINITION | OBJECT\n\ndirective @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ndirective @interfaceObject on OBJECT\n\ndirective @key(fields: openfed__FieldSet!, resolvable: Boolean = true) repeatable on INTERFACE | OBJECT\n\ndirective @link(as: String, for: String, import: [String], url: String!) repeatable on SCHEMA\n\ndirective @override(from: String!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @provides(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requires(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requiresScopes(scopes: [[openfed__Scope!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\ndirective @shareable on FIELD_DEFINITION | OBJECT\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\n\"\"\"Scalar for BigDecimal\"\"\"\nscalar BigDecimal\n\n\"\"\"Scalar for BigInteger\"\"\"\nscalar BigInteger\n\n\"\"\"Scalar for Date\"\"\"\nscalar Date\n\n\"\"\"Scalar for FieldSet\"\"\"\nscalar FieldSet\n\n\"\"\"Scalar for Import\"\"\"\nscalar Import\n\ntype Order @key(fields: \"id\") {\n  customerName: String\n  customerNumber: String\n  id: String\n  \"\"\"ISO-8601\"\"\"\n  orderDate: Date\n  orderItems: [OrderItem]\n  orderNumber: String\n}\n\ntype OrderItem {\n  amount: Int\n  id: String\n  position: Int\n  product: Product\n  productId: String\n}\n\n\"\"\"Scalar for Policy\"\"\"\nscalar Policy\n\ntype Product @key(fields: \"id\") {\n  id: ID @external\n}\n\nenum Purpose {\n  \"\"\"\n  `EXECUTION` features provide metadata necessary for operation execution.\n  \"\"\"\n  EXECUTION\n  \"\"\"\n  `SECURITY` features provide metadata necessary to securely resolve fields.\n  \"\"\"\n  SECURITY\n}\n\n\"\"\"Query root\"\"\"\ntype Query {\n  order(id: String): Order\n}\n\n\"\"\"Scalar for Scope\"\"\"\nscalar Scope\n\nscalar openfed__FieldSet\n\nscalar openfed__Scope","5c21f30565a3309126903fe8604576d73d253492":"schema {\n  query: Query\n}\n\ndirective @authenticated on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @composeDirective(name: String!) repeatable on SCHEMA\n\n\"Indicates a Bean Validation constraint\"\ndirective @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\ndirective @eventsPublish(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsRequest(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @eventsSubscribe(sourceName: String! = \"default\", topic: String!) on FIELD_DEFINITION\n\ndirective @extends on INTERFACE | OBJECT\n\ndirective @external on FIELD_DEFINITION | OBJECT\n\ndirective @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\ndirective @interfaceObject on OBJECT\n\ndirective @key(fields: openfed__FieldSet!, resolvable: Boolean = true) repeatable on INTERFACE | OBJECT\n\ndirective @link(as: String, for: String, import: [String], url: String!) repeatable on SCHEMA\n\ndirective @override(from: String!) on FIELD_DEFINITION\n\n\"Indicates to composition that the target element is restricted based on authorization policies that are evaluated in a Rhai script or coprocessor.\"\ndirective @policy(policies: [[Policy!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\ndirective @provides(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requires(fields: openfed__FieldSet!) on FIELD_DEFINITION\n\ndirective @requiresScopes(scopes: [[openfed__Scope!]!]!) on ENUM | FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR\n\n\"Used to specify the role required to execute a given field or operation.\"\ndirective @rolesAllowed(value: String) on FIELD_DEFINITION\n\ndirective @shareable on FIELD_DEFINITION | OBJECT\n\ndirective @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION\n\n\"\"\"Scalar for BigDecimal\"\"\"\nscalar BigDecimal\n\n\"\"\"Scalar for BigInteger\"\"\"\nscalar BigInteger\n\n\"\"\"Scalar for FieldSet\"\"\"\nscalar FieldSet\n\n\"\"\"Scalar for Import\"\"\"\nscalar Import\n\n\"\"\"Scalar for Policy\"\"\"\nscalar Policy\n\ntype Product @key(fields: \"id\") {\n  id: ID\n  \"\"\"The price in cent\"\"\"\n  price: Int\n}\n\nenum Purpose {\n  \"\"\"\n  `EXECUTION` features provide metadata necessary for operation execution.\n  \"\"\"\n  EXECUTION\n  \"\"\"\n  `SECURITY` features provide metadata necessary to securely resolve fields.\n  \"\"\"\n  SECURITY\n}\n\n\"\"\"Query root\"\"\"\ntype Query {\n  productPrice(id: ID): Product\n  productPrices(ids: [String]): [Product]\n}\n\n\"\"\"Scalar for Scope\"\"\"\nscalar Scope\n\nscalar openfed__FieldSet\n\nscalar openfed__Scope"}},"subgraphs":[{"id":"0","name":"product","routingUrl":"http://localhost:18482/graphql"},{"id":"1","name":"order","routingUrl":"http://localhost:18483/graphql"},{"id":"2","name":"price","routingUrl":"http://localhost:18484/graphql"}]}